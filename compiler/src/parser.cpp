// This file is part of the Yu programming language and is licensed under MIT License;
// See LICENSE.txt for details

#include "../include/parser.h"
#include <iomanip>
#include <iostream>
#include "../../common/styles.h"

namespace yu::compiler
{
    /**
     * @brief Creates a detailed parse error object with comprehensive error information.
     *
     * Constructs a ParseError with contextual details about the error location, 
     * severity, and potential resolution. Uses the lexer to extract line and column 
     * information and generates a source line and error pointer for precise error reporting.
     *
     * @param flags Bitwise flags indicating the type or category of parse error
     * @param severity Error severity level (warning, error, fatal)
     * @param message Descriptive error message explaining the parsing issue
     * @param suggestion Recommended fix or correction for the error
     * @param token_index Index of the token where the error occurred
     *
     * @return ParseError object with comprehensive error details
     *
     * @note The method is const, indicating it does not modify the parser's state
     */
    ParseError Parser::create_parse_error(const ParseErrorFlags flags, const ErrorSeverity severity,
                                          const std::string &message, const std::string &suggestion,
                                          const uint32_t token_index) const
    {
        const auto [line, col] = lexer.get_line_col(current_token);
        return {
            flags,
            severity,
            message,
            suggestion,
            file_name,
            line,
            col,
            get_source_line(token_index),
            create_error_pointer(token_index)
        };
    }

    /**
     * @brief Constructs a Parser object for parsing tokens from a source file.
     *
     * @param tokens Reference to the list of tokens generated by the lexer
     * @param source Pointer to the raw source code string
     * @param file_name Name of the source file being parsed
     * @param lexer Reference to the lexer used for token generation
     *
     * Initializes the parser with the necessary context for parsing, including
     * tokens, source code, file name, and the lexer. After initialization,
     * sets the current token to the first token in the list.
     */
    Parser::Parser(lang::TokenList &tokens, const char *source, const char *file_name,
                   const Lexer &lexer): lexer(lexer),
                                        tokens(tokens), source(source),
                                        file_name(file_name)
    {
        update_current_token();
    }

    /**
     * @brief Parses the entire program, processing variable and function declarations.
     *
     * This method iterates through the token list, parsing variable and function declarations
     * until the end of the file is reached. It initializes and resets various parsing state
     * variables before beginning the parsing process.
     *
     * @details The parsing process handles the following top-level constructs:
     * - Variable declarations (with 'var' or 'const' keywords)
     * - Function declarations
     *
     * @return ParseResult<int> Indicates the parsing result:
     *         - Success: Returns 1 if the entire program is successfully parsed
     *         - Failure: Returns a failure result if an unexpected token is encountered
     *                    or if a declaration parsing fails
     *
     * @note The method will report an error and stop parsing if an unexpected token is found
     * @note Initializes and resets parsing state variables like var_declrs, symbols, types, etc.
     *
     * @throws None Errors are reported through the error reporting mechanism
     */
    ParseResult<int> Parser::parse_program()
    {
        var_declrs = VarDeclList {};
        symbols = SymbolList {};
        types = TypeList {};
        expressions = ExprList {};
        current_scope = 0;
        current = 0;
        update_current_token();

        while (!is_at_end())
        {
            switch (current_token.type)
            {
                case lang::token_i::VAR:
                case lang::token_i::CONST:
                {
                    auto var_decl = parse_variable_decl();
                    if (!var_decl)
                    {
                        return ParseResult<int>::failure();
                    }
                    break;
                }
                case lang::token_i::FUNCTION:
                {
                    if (const auto func_decl = parse_function_decl();
                        !func_decl)
                    {
                        return ParseResult<int>::failure();
                    }
                    break;
                }
                case lang::token_i::END_OF_FILE:
                    return ParseResult(0);

                default:
                {
                    report_error(create_parse_error(
                        ParseErrorFlags::UNEXPECTED_TOKEN,
                        ErrorSeverity::ERROR,
                        "Unexpected token in program",
                        "Remove or replace this token",
                        current
                    ));
                    return ParseResult<int>::failure();
                }
            }
        }

        return ParseResult(1);
    }

    /**
     * @brief Parses a function declaration in the Yu programming language.
     *
     * This method handles the complete parsing of a function declaration, including:
     * - Optional generic parameters
     * - Function name
     * - Parameter list with names and types
     * - Return type specification
     * - Function body
     *
     * @return ParseResult containing the function type index if successful, or a failure result
     *
     * @details The function declaration follows the syntax:
     * fn [<generic_params>] function_name(param1: type1, param2: type2, ...) -> return_type { body }
     *
     * @note Performs comprehensive error checking at each stage of parsing
     * @note Adds function symbol, parameters, and type information to respective tables
     * @throws None Errors are handled through ParseResult and error reporting
     *
     * @example
     * fn add(x: int, y: int) -> int { return x + y; }
     * fn generic_func<T>(value: T) -> T { return value; }
     */
    ParseResult<uint32_t> Parser::parse_function_decl()
    {
        //const uint32_t func_index = types.names.size();
        advance();

        // TODO: Make actually generics
        if (current_token.type == lang::token_i::LESS)
        {
            auto generic_result = parse_generic_params();
            if (!generic_result)
                return ParseResult<uint32_t>::failure();
        }

        // fn name
        if (current_token.type != lang::token_i::IDENTIFIER)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected function name",
                "Provide a valid function name",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        const std::string_view func_name {
            source + tokens.starts[current],
            tokens.lengths[current]
        };
        const uint32_t func_symbol_index = add_symbol(
            func_name,
            std::numeric_limits<uint32_t>::max(),
            static_cast<uint8_t>(SymbolFlags::IS_FUNCTION)
        );
        advance();
        if (current_token.type != lang::token_i::LEFT_PAREN)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected '(' to start parameter list",
                "Open parameter list with '('",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        advance();

        uint32_t param_start = types.function_params.size();
        uint32_t param_count = 0;
        std::vector<uint32_t> param_types;
        std::vector<std::string_view> param_names;

        while (current_token.type != lang::token_i::RIGHT_PAREN)
        {
            if (current_token.type != lang::token_i::IDENTIFIER)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected parameter name",
                    "Provide a valid parameter name",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }

            std::string_view param_name {
                source + tokens.starts[current],
                tokens.lengths[current]
            };
            param_names.push_back(param_name);
            advance();

            if (current_token.type != lang::token_i::COLON)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected ':' after parameter name",
                    "Provide type annotation for parameter",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();

            auto type_result = parse_type();
            if (!type_result)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid parameter type",
                    "Provide a valid type for parameter",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }

            add_symbol(
                param_name,
                type_result.value,
                0
            );

            param_types.push_back(type_result.value);
            types.function_params.push_back(type_result.value);
            param_count++;

            if (current_token.type == lang::token_i::COMMA)
                advance();
            else if (current_token.type != lang::token_i::RIGHT_PAREN)
                break;
        }

        if (current_token.type != lang::token_i::RIGHT_PAREN)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected ')' to close parameter list",
                "Close parameter list with ')'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        advance();

        if (current_token.type != lang::token_i::MINUS)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected '-' before return type",
                "Specify return type with '->'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        advance();

        if (current_token.type != lang::token_i::GREATER)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected '>' to complete return type arrow",
                "Complete return type specification with '->'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        advance();

        const auto return_type_result = parse_type();
        if (!return_type_result)
        {
            report_error(create_parse_error(
                ParseErrorFlags::INVALID_SYNTAX,
                ErrorSeverity::ERROR,
                "Invalid return type",
                "Provide a valid return type",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        symbols.type_indices[func_symbol_index] = return_type_result.value;

        const uint32_t function_type_index = types.names.size();
        types.names.push_back("function");
        types.function_param_starts.push_back(param_start);
        types.function_param_counts.push_back(param_count);
        types.function_return_types.push_back(return_type_result.value);

        types.generic_starts.push_back(0);
        types.generic_counts.push_back(0);

        if (current_token.type != lang::token_i::LEFT_BRACE)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected '{' to start function body",
                "Open function body with '{'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        if (const auto function_body = parse_statement();
            !function_body)
        {
            report_error(create_parse_error(
                ParseErrorFlags::INVALID_SYNTAX,
                ErrorSeverity::ERROR,
                "Invalid function body",
                "Provide a valid function body",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        return ParseResult(function_type_index);
    }

    /**
     * @brief Parses a variable declaration in the Yu programming language.
     *
     * This method handles parsing of variable declarations, supporting both 'var' and 'const' keywords,
     * with optional type annotations and mandatory initialization.
     *
     * @details The method performs the following steps:
     * - Checks for 'var' or 'const' keyword
     * - Validates the variable identifier
     * - Optionally parses type annotation
     * - Requires initialization expression
     * - Infers type if not explicitly specified
     * - Adds variable information to declaration tracking structures
     *
     * @return ParseResult<uint32_t> 
     * - On success: Returns the index of the parsed variable in the declaration list
     * - On failure: Returns a failure result with an associated error
     *
     * @note Errors are reported for:
     * - Missing or incorrect keywords
     * - Invalid identifiers
     * - Invalid type specifications
     * - Missing initialization
     * - Invalid initialization expressions
     * - Missing semicolon
     *
     * @throws None Errors are handled through ParseResult and error reporting
     */
    ParseResult<uint32_t> Parser::parse_variable_decl()
    {
        const uint32_t var_index = var_declrs.names.size();

        const bool is_const = match(lang::token_i::CONST);
        if (!is_const && !match(lang::token_i::VAR))
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected 'var' or 'const' at the start of variable declaration",
                "Use 'var' or 'const' when declaring a variable",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        if (current_token.type != lang::token_i::IDENTIFIER)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected identifier after 'var' or 'const'",
                "Provide a valid variable name",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        var_declrs.names.emplace_back(std::string_view {
            source + tokens.starts[current],
            tokens.lengths[current]
        });
        advance();

        uint32_t type_idx = std::numeric_limits<uint32_t>::max();
        if (match(lang::token_i::COLON))
        {
            auto type_result = parse_type();
            if (!type_result)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid type specification",
                    "Provide a valid type after ':'",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            type_idx = type_result.value;
        }

        if (!match(lang::token_i::EQUAL))
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected '=' for variable initialization",
                "Use '=' to assign a value to the variable",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        auto init_result = parse_expression();
        if (!init_result)
        {
            report_error(create_parse_error(
                ParseErrorFlags::INVALID_SYNTAX,
                ErrorSeverity::ERROR,
                "Invalid expression in variable initialization",
                "Provide a valid expression after '='",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        if (type_idx == std::numeric_limits<uint32_t>::max())
        {
            type_idx = infer_type(init_result.value);
            if (type_idx == std::numeric_limits<uint32_t>::max())
            {
                report_error(create_parse_error(
                    ParseErrorFlags::TYPE_MISMATCH,
                    ErrorSeverity::ERROR,
                    "Unable to infer type for variable",
                    "Provide an explicit type annotation",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
        }

        var_declrs.type_indices.emplace_back(type_idx);
        var_declrs.init_indices.emplace_back(init_result.value);
        var_declrs.flags.emplace_back(is_const);

        var_declrs.lines.emplace_back(current_token.start);
        var_declrs.columns.emplace_back(current_token.length);

        if (!match(lang::token_i::SEMICOLON))
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected ';' at the end of variable declaration",
                "Add ';' to complete the variable declaration",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        return ParseResult(var_index);
    }

    /**
     * @brief Checks if the parser has reached the end of the token stream.
     *
     * Determines whether parsing is complete by checking if the current token index 
     * has exceeded the total number of tokens or if the current token is an end-of-file marker.
     *
     * @return true if parsing has reached the end of the token stream, false otherwise
     * @note This method is a const member function, meaning it does not modify the parser's state
     */
    bool Parser::is_at_end() const
    {
        return current >= tokens.size() || tokens.types[current] == lang::token_i::END_OF_FILE;
    }

    /**
     * @brief Advances the parser to the next token in the token list.
     *
     * Increments the current token index and updates the current token reference.
     * This method is used to progress through the token stream during parsing.
     *
     * @return A reference to the newly current token after advancing
     *
     * @note This method modifies the internal state of the parser by:
     *       1. Incrementing the current token index
     *       2. Updating the current_token reference
     */
    const lang::token_t &Parser::advance()
    {
        current++;
        update_current_token();
        return current_token;
    }

    /**
     * @brief Checks if the current token matches the specified type and advances the parser.
     *
     * This method checks if the current token matches the given token type. If there is a match,
     * the parser advances to the next token and updates the current token state.
     *
     * @param type The token type to match against the current token.
     * @return bool True if the current token matches the specified type, false otherwise.
     *
     * @note If a match is found, the parser advances to the next token and updates the current token.
     * @note If the parser is at the end of the token list, this method returns false.
     */
    bool Parser::match(const lang::token_i type)
    {
        const bool matches = !is_at_end() && tokens.types[current] == type;
        current += matches;
        if (matches)
            update_current_token();
        return matches;
    }

    /**
     * @brief Updates the current token based on the current index in the token list.
     *
     * This method populates the `current_token` member with the token details 
     * from the token lists at the current index. It extracts the start position, 
     * length, type, and flags for the current token.
     *
     * @note This method is typically called after advancing the token index to 
     * ensure the `current_token` reflects the most recent token being processed.
     */
    void Parser::update_current_token()
    {
        current_token = {
            tokens.starts[current],
            tokens.lengths[current],
            tokens.types[current],
            tokens.flags[current]
        };
    }

    /**
     * @brief Infers the type of an expression based on its index.
     *
     * This method determines the type of an expression by examining its index in the expressions list.
     * It handles various literal types, identifiers, and special tokens, returning the corresponding type index.
     *
     * @param expr_index The index of the expression in the expressions list.
     * @return uint32_t The type index of the expression. Returns std::numeric_limits<uint32_t>::max() if type cannot be inferred.
     *
     * Type inference rules:
     * - Numeric literals: F64 for floating-point, I32 for integer
     * - Boolean literals: BOOLEAN type
     * - String literals: STRING type
     * - Identifiers: Looks up symbol type in symbol table
     * - NIL: Returns max value indicating no type
     *
     * @note Returns std::numeric_limits<uint32_t>::max() for out-of-bounds indices or unrecognized types.
     */
    uint32_t Parser::infer_type(uint32_t expr_index)
    {
        if (expr_index >= expressions.expr_types.size())
            return std::numeric_limits<uint32_t>::max();

        if (expressions.expr_types[expr_index] < types.names.size())
        {
            return expressions.expr_types[expr_index];
        }

        switch (static_cast<lang::token_i>(expressions.expr_types[expr_index]))
        {
            case lang::token_i::NUM_LITERAL:
            {
                const std::string_view value = expressions.values[expr_index];
                return value.find('.') != std::string_view::npos
                           ? static_cast<uint32_t>(lang::token_i::F64)
                           : static_cast<uint32_t>(lang::token_i::I32);
            }

            case lang::token_i::TRUE:
            case lang::token_i::FALSE:
                return static_cast<uint32_t>(lang::token_i::BOOLEAN);

            case lang::token_i::STR_LITERAL:
                return static_cast<uint32_t>(lang::token_i::STRING);

            case lang::token_i::NIL:
                return std::numeric_limits<uint32_t>::max();

            case lang::token_i::IDENTIFIER:
            {
                const std::string_view identifier = expressions.values[expr_index];

                if (const uint32_t symbol_index = lookup_symbol(identifier);
                    symbol_index != -1)
                    return symbols.type_indices[symbol_index];
                return std::numeric_limits<uint32_t>::max();
            }

            default:
                return std::numeric_limits<uint32_t>::max();
        }
    }

    /**
     * @brief Adds a new symbol to the symbol table.
     *
     * Registers a symbol with its associated name, type, and flags in the parser's symbol table.
     * The symbol is added to the current scope and assigned a unique index.
     *
     * @param name A string view representing the symbol's name
     * @param type_index The index of the symbol's type in the type system
     * @param flags Bitfield of symbol attributes (e.g., visibility, mutability)
     *
     * @return uint32_t The index of the newly added symbol in the symbol table
     *
     * @note The symbol is added to the current scope and can be later retrieved using its index
     */
    uint32_t Parser::add_symbol(std::string_view name, uint32_t type_index, uint8_t flags)
    {
        const uint32_t symbol_index = symbols.names.size();

        symbols.names.emplace_back(name);
        symbols.type_indices.emplace_back(type_index);
        symbols.scopes.emplace_back(current_scope);
        symbols.symbol_flags.emplace_back(flags);

        return symbol_index;
    }

    /**
     * @brief Searches for a symbol by name in the symbol table.
     *
     * Performs a reverse lookup through the symbol table to find the index of a symbol 
     * with the given name. The search starts from the most recently added symbol and 
     * moves backwards, which supports scoping rules where more recent (local) symbols 
     * take precedence over earlier (global) symbols.
     *
     * @param name A string view representing the name of the symbol to find
     * @return uint32_t The index of the symbol in the symbol table, or -1 if not found
     * @note Time complexity is O(n) where n is the number of symbols in the table
     */
    uint32_t Parser::lookup_symbol(const std::string_view name) const
    {
        for (int32_t i = symbols.names.size() - 1; i >= 0; --i)
        {
            if (symbols.names[i] == name)
                return i;
        }
        return -1;
    }

    /**
     * @brief Parses a type declaration in the Yu programming language.
     *
     * This method handles parsing of various type declarations, including:
     * - Primitive types (u8, i8, u16, i16, u32, i32, u64, i64, f32, f64)
     * - String and boolean types
     * - Void type
     * - Pointer types with optional generic type parameters
     * - Generic type parameters
     *
     * @return A ParseResult containing the index of the parsed type in the types collection,
     *         or a failure result if type parsing fails.
     *
     * @details The method performs the following steps:
     * 1. Handles built-in primitive types
     * 2. Supports pointer types with generic type parameters
     * 3. Validates generic type parameters
     * 4. Checks for generic type parameters in the current scope
     * 5. Reports detailed errors for unrecognized or invalid types
     *
     * @note Advances the current token upon successful type parsing
     * @note Adds type information to the types collection
     *
     * @throws None Errors are reported through the error reporting mechanism
     */
    ParseResult<uint32_t> Parser::parse_type()
    {
        const uint32_t type_index = types.names.size();

        switch (current_token.type)
        {
            case lang::token_i::U8:
            case lang::token_i::I8:
            case lang::token_i::U16:
            case lang::token_i::I16:
            case lang::token_i::U32:
            case lang::token_i::I32:
            case lang::token_i::U64:
            case lang::token_i::I64:
            case lang::token_i::F32:
            case lang::token_i::F64:
            case lang::token_i::STRING:
            case lang::token_i::BOOLEAN:
            case lang::token_i::VOID:
            {
                std::string_view name {
                    source + tokens.starts[current],
                    tokens.lengths[current]
                };
                types.names.emplace_back(name);
                types.generic_starts.emplace_back(0);
                types.generic_counts.emplace_back(0);
                advance();
                return ParseResult(type_index);
            }

            case lang::token_i::PTR:
            {
                std::string_view name {
                    source + tokens.starts[current],
                    tokens.lengths[current]
                };
                types.names.emplace_back(name);
                advance();

                if (match(lang::token_i::LESS))
                {
                    const uint32_t generic_start = types.generic_params.size();
                    uint32_t generic_count = 0;

                    do
                    {
                        auto param_type_result = parse_type();
                        if (!param_type_result)
                        {
                            report_error(create_parse_error(
                                ParseErrorFlags::INVALID_SYNTAX,
                                ErrorSeverity::ERROR,
                                "Invalid generic type parameter",
                                "Provide a valid type for generic parameter",
                                current
                            ));
                            return ParseResult<uint32_t>::failure();
                        }

                        types.generic_params.emplace_back(param_type_result.value);
                        generic_count++;
                    }
                    while (match(lang::token_i::COMMA));

                    if (!match(lang::token_i::GREATER))
                    {
                        report_error(create_parse_error(
                            ParseErrorFlags::UNEXPECTED_TOKEN,
                            ErrorSeverity::ERROR,
                            "Expected '>' to close generic type parameters",
                            "Close generic type parameters with '>'",
                            current
                        ));
                        return ParseResult<uint32_t>::failure();
                    }

                    types.generic_starts.emplace_back(generic_start);
                    types.generic_counts.emplace_back(generic_count);
                }
                else
                {
                    types.generic_starts.emplace_back(0);
                    types.generic_counts.emplace_back(0);
                }

                return ParseResult(type_index);
            }

            case lang::token_i::IDENTIFIER:
            {
                std::string_view name {
                    source + tokens.starts[current],
                    tokens.lengths[current]
                };

                uint32_t symbol_index = lookup_symbol(name);
                if (symbol_index != -1 &&
                    (symbols.symbol_flags[symbol_index] & static_cast<uint8_t>(SymbolFlags::IS_GENERIC_PARAM)))
                {
                    types.names.emplace_back(name);
                    types.generic_starts.emplace_back(0);
                    types.generic_counts.emplace_back(0);
                    advance();
                    return ParseResult(type_index);
                }

                report_error(create_parse_error(
                    ParseErrorFlags::UNRESOLVED_SYMBOL,
                    ErrorSeverity::ERROR,
                    "Unrecognized type",
                    "Use a valid type or define the type before use",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            default:
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNRESOLVED_SYMBOL,
                    ErrorSeverity::ERROR,
                    "Unrecognized type",
                    "Use a valid type or define the type before use",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
        }
    }

    /**
     * @brief Parses a statement based on the current token type.
     *
     * This method handles different types of statements in the Yu programming language,
     * including if statements, block statements, variable declarations, return statements,
     * and expression statements.
     *
     * @return ParseResult<uint32_t> A result containing the index of the parsed statement
     *         or an error if parsing fails. The returned index can be used for further
     *         semantic analysis or code generation.
     *
     * @note Supported statement types:
     * - If statements (starting with 'if' keyword)
     * - Block statements (enclosed in curly braces)
     * - Variable declarations (using 'var' or 'const' keywords)
     * - Return statements
     * - Expression statements (default fallback)
     *
     * @throws Potential parsing errors if the statement cannot be correctly parsed
     */
    ParseResult<uint32_t> Parser::parse_statement()
    {
        switch (current_token.type)
        {
            case lang::token_i::IF:
                return parse_if_statement();

            case lang::token_i::LEFT_BRACE:
                return parse_block_statement();

            case lang::token_i::VAR:
            case lang::token_i::CONST:
                return parse_variable_decl();

            case lang::token_i::RETURN:
                return parse_return_statement();

            default:
                return parse_expression_statement();
        }
    }

    /**
     * @brief Parses an if statement in the Yu programming language.
     *
     * This method handles parsing of if-else statements, including:
     * - Validating the opening parenthesis after 'if'
     * - Parsing the condition expression
     * - Parsing the then branch statement
     * - Optionally parsing an else branch
     *
     * @return ParseResult<uint32_t> A result containing the index of the parsed if statement or a failure
     *
     * @throws ParseError if there are syntax errors in the if statement structure
     *
     * @note The method advances the token stream during parsing
     * @note Currently uses a placeholder index (std::numeric_limits<uint32_t>::max())
     *
     * @example
     * // Valid if statement examples:
     * if (x > 0) { return x; }
     * if (y < 10) { doSomething(); } else { doSomethingElse(); }
     */
    ParseResult<uint32_t> Parser::parse_if_statement()
    {
        constexpr uint32_t if_index = std::numeric_limits<uint32_t>::max(); // TODO: track if statement

        advance();
        if (current_token.type != lang::token_i::LEFT_PAREN)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected '(' after 'if'",
                "Open condition with '('",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        advance();

        if (const auto condition_result = parse_expression();
            !condition_result)
        {
            report_error(create_parse_error(
                ParseErrorFlags::INVALID_SYNTAX,
                ErrorSeverity::ERROR,
                "Invalid condition expression",
                "Provide a valid condition",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        if (current_token.type != lang::token_i::RIGHT_PAREN)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected ')' after condition",
                "Close condition with ')'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        advance();

        if (const auto then_branch = parse_statement();
            !then_branch)
        {
            report_error(create_parse_error(
                ParseErrorFlags::INVALID_SYNTAX,
                ErrorSeverity::ERROR,
                "Invalid statement in 'if' block",
                "Provide a valid statement",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        if (match(lang::token_i::ELSE))
        {
            if (const auto else_branch = parse_statement();
                !else_branch)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid statement in 'else' block",
                    "Provide a valid statement",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
        }

        return ParseResult(if_index);
    }

    /**
     * @brief Parses a block statement enclosed in curly braces.
     *
     * This method handles parsing a sequence of statements within a block, 
     * managing scope and token progression. It increments the current scope 
     * when entering the block and decrements it upon exiting.
     *
     * @details The method performs the following steps:
     * - Advances past the opening left brace
     * - Increments the current scope
     * - Parses statements until the right brace is encountered
     * - Advances past the right brace
     * - Decrements the current scope
     *
     * @return ParseResult<uint32_t> 
     * - Returns a successful result with a block index (currently a placeholder max value)
     * - Returns a failure result if any statement parsing fails
     *
     * @note The block index tracking is currently a TODO and uses a placeholder max value
     * @note Errors during statement parsing are handled within the parse_statement() method
     */
    ParseResult<uint32_t> Parser::parse_block_statement()
    {
        constexpr uint32_t block_index = std::numeric_limits<uint32_t>::max(); // TODO: track block

        advance();
        current_scope++;
        while (current_token.type != lang::token_i::RIGHT_BRACE)
        {
            // error is handled by parse_statement();
            if (const auto statement = parse_statement();
                !statement)
            {
                return ParseResult<uint32_t>::failure();
            }
        }

        advance();
        current_scope--;
        return ParseResult(block_index);
    }

    /**
     * @brief Parses a return statement in the Yu programming language.
     *
     * This method handles parsing of return statements, which can optionally include an expression.
     * It ensures proper syntax by checking for a semicolon and validating the return expression.
     *
     * @return A ParseResult containing the return statement's index or a failure if parsing fails.
     *
     * @note Currently uses a placeholder index (std::numeric_limits<uint32_t>::max()) for tracking returns.
     *
     * @throws ParseError if the return statement has invalid syntax or is missing a semicolon.
     *
     * @example
     * // Valid return statements
     * return;           // Void return
     * return 42;        // Return with an expression
     * return foo();     // Return with a function call
     */
    ParseResult<uint32_t> Parser::parse_return_statement()
    {
        constexpr uint32_t return_index = std::numeric_limits<uint32_t>::max(); // TODO: track return

        advance();
        if (current_token.type != lang::token_i::SEMICOLON)
        {
            if (const auto return_expr = parse_expression();
                !return_expr)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid return expression",
                    "Provide a valid expression to return",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
        }

        if (!match(lang::token_i::SEMICOLON))
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected ';' after return statement",
                "End return statement with ';'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        return ParseResult(return_index);
    }


    /**
     * @brief Parses generic type parameters for functions or types.
     *
     * This method handles parsing of generic parameters enclosed in angle brackets,
     * supporting multiple generic parameters, optional variadic parameters, and
     * nested generic parameters.
     *
     * @details The method performs the following key operations:
     * - Validates the opening '<' token for generic parameters
     * - Parses individual generic parameter identifiers
     * - Supports a single variadic parameter (using '...')
     * - Adds generic parameters to the symbol table
     * - Handles nested generic parameters
     * - Validates token sequence and syntax
     *
     * @return ParseResult<uint32_t> 
     * - On success: Returns the starting index of generic parameters
     * - On failure: Returns a failure result with appropriate error details
     *
     * @note Errors are reported for:
     * - Missing or incorrect opening/closing tokens
     * - Multiple variadic parameters
     * - Invalid generic parameter identifiers
     * - Incorrect token sequences
     *
     * @example
     * // Valid generic parameter declarations
     * func<T>()           // Single type parameter
     * func<T, U>()        // Multiple type parameters
     * func<T...>()        // Variadic type parameter
     * func<T<U>>()        // Nested generic parameters
     */
    ParseResult<uint32_t> Parser::parse_generic_params()
    {
        const uint32_t generic_start = types.generic_params.size();
        uint32_t generic_count = 0;
        auto has_variadic = false;

        if (current_token.type != lang::token_i::LESS)
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected '<' to start generic parameters",
                "Open generic parameters with '<'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }
        advance();

        while (current_token.type != lang::token_i::GREATER)
        {
            if (current_token.type == lang::token_i::DOT &&
                tokens.types[current + 1] == lang::token_i::DOT &&
                tokens.types[current + 2] == lang::token_i::DOT)
            {
                if (has_variadic)
                {
                    report_error(create_parse_error(
                        ParseErrorFlags::INVALID_SYNTAX,
                        ErrorSeverity::ERROR,
                        "Multiple variadic generic parameters",
                        "Only one variadic generic parameter is allowed",
                        current
                    ));
                    return ParseResult<uint32_t>::failure();
                }
                has_variadic = true;
                advance(); // first dot
                advance(); // second dot
                advance(); // third dot
            }

            if (current_token.type != lang::token_i::IDENTIFIER)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected identifier in generic parameters",
                    "Provide a valid identifier for generic parameter",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }

            uint32_t param_index = add_symbol(
                std::string_view(source + tokens.starts[current], tokens.lengths[current]),
                std::numeric_limits<uint32_t>::max(),
                static_cast<uint8_t>(SymbolFlags::IS_GENERIC_PARAM)
            );

            types.generic_params.push_back(param_index);
            generic_count++;
            advance();

            if (current_token.type == lang::token_i::LESS)
            {
                if (const auto nested_result = parse_generic_params();
                    !nested_result)
                {
                    return ParseResult<uint32_t>::failure();
                }
            }

            if (current_token.type == lang::token_i::COMMA)
            {
                advance();
            }
            else if (current_token.type != lang::token_i::GREATER)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected ',' or '>' in generic parameters",
                    "Separate generic parameters with ',' or close with '>'",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
        }

        advance();
        types.generic_starts.push_back(generic_start);
        types.generic_counts.push_back(generic_count);

        return ParseResult(generic_start);
    }

    /**
     * @brief Parses an expression statement, ensuring it ends with a semicolon.
     *
     * This method attempts to parse an expression and verify that it is followed by a semicolon.
     * If the expression is invalid or the semicolon is missing, it reports an appropriate error.
     *
     * @return ParseResult<uint32_t> An index representing the parsed expression statement,
     *         or a failure result if parsing fails due to invalid syntax or missing semicolon.
     *
     * @throws None Errors are reported through the error reporting mechanism, not thrown.
     *
     * @note Currently uses a placeholder index (std::numeric_limits<uint32_t>::max())
     *       for tracking expression statements.
     *
     * @see parse_expression()
     * @see report_error()
     */
    ParseResult<uint32_t> Parser::parse_expression_statement()
    {
        constexpr uint32_t expr_stmt_index = std::numeric_limits<uint32_t>::max(); // TODO: track expression statement

        if (const auto expr = parse_expression();
            !expr)
        {
            report_error(create_parse_error(
                ParseErrorFlags::INVALID_SYNTAX,
                ErrorSeverity::ERROR,
                "Invalid expression statement",
                "Provide a valid expression",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        if (!match(lang::token_i::SEMICOLON))
        {
            report_error(create_parse_error(
                ParseErrorFlags::UNEXPECTED_TOKEN,
                ErrorSeverity::ERROR,
                "Expected ';' after expression",
                "End expression statement with ';'",
                current
            ));
            return ParseResult<uint32_t>::failure();
        }

        return ParseResult(expr_stmt_index);
    }

    /**
     * @brief Parses an expression in the Yu programming language.
     *
     * This method handles parsing of various expression types, including:
     * - Unary expressions (with +, -, &, ~)
     * - Function declarations
     * - Parenthesized expressions
     * - Primary expressions (literals, identifiers)
     * - Binary expressions with various operators
     *
     * @return ParseResult containing the index of the parsed expression in the expressions list,
     *         or a failure result if parsing fails
     *
     * @note Supports complex parsing scenarios like:
     * - Function literals with generic parameters
     * - Variadic function parameters
     * - Nested expressions
     * - Multiple binary operator precedence
     *
     * @throws ParseError if invalid syntax is encountered during parsing
     */
    ParseResult<uint32_t> Parser::parse_expression()
    {
        const uint32_t expr_index = expressions.expr_types.size();

        if (current_token.type == lang::token_i::MINUS ||
            current_token.type == lang::token_i::PLUS ||
            current_token.type == lang::token_i::AND ||
            current_token.type == lang::token_i::TILDE)
        {
            expressions.expr_types.emplace_back(static_cast<uint8_t>(current_token.type));
            expressions.values.emplace_back(std::string_view {
                source + tokens.starts[current],
                tokens.lengths[current]
            });
            advance();
        }

        if (current_token.type == lang::token_i::FUNCTION)
        {
            uint32_t param_start = types.function_params.size();
            uint32_t param_count = 0;
            uint32_t generic_start = std::numeric_limits<uint32_t>::max();
            uint32_t generic_count = 0;

            advance();
            if (current_token.type == lang::token_i::LESS)
            {
                auto generic_result = parse_generic_params();
                if (!generic_result)
                    return ParseResult<uint32_t>::failure();

                generic_start = generic_result.value;
                generic_count = types.generic_counts.back();
            }

            // parse param list
            if (current_token.type != lang::token_i::LEFT_PAREN)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected '(' to start parameter list",
                    "Open parameter list with '('",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();

            std::vector<uint32_t> param_types;
            while (current_token.type != lang::token_i::RIGHT_PAREN)
            {
                // variadic params handling
                auto is_variadic = false;
                if (current_token.type == lang::token_i::DOT &&
                    tokens.types[current + 1] == lang::token_i::DOT &&
                    tokens.types[current + 2] == lang::token_i::DOT)
                {
                    is_variadic = true;
                    advance(); // first dot
                    advance(); // second dot
                    advance(); // third dot
                }

                if (current_token.type != lang::token_i::IDENTIFIER)
                {
                    report_error(create_parse_error(
                        ParseErrorFlags::UNEXPECTED_TOKEN,
                        ErrorSeverity::ERROR,
                        "Expected parameter name",
                        "Provide a valid parameter name",
                        current
                    ));
                    return ParseResult<uint32_t>::failure();
                }
                advance();

                if (current_token.type != lang::token_i::COLON)
                {
                    report_error(create_parse_error(
                        ParseErrorFlags::UNEXPECTED_TOKEN,
                        ErrorSeverity::ERROR,
                        "Expected ':' after parameter name",
                        "Provide type annotation for parameter",
                        current
                    ));
                    return ParseResult<uint32_t>::failure();
                }
                advance();

                auto type_result = parse_type();
                if (!type_result)
                {
                    report_error(create_parse_error(
                        ParseErrorFlags::INVALID_SYNTAX,
                        ErrorSeverity::ERROR,
                        "Invalid parameter type",
                        "Provide a valid type for parameter",
                        current
                    ));
                    return ParseResult<uint32_t>::failure();
                }

                param_types.push_back(type_result.value);
                types.function_params.push_back(type_result.value);
                param_count++;
                if (is_variadic)
                {
                    if (current_token.type == lang::token_i::DOT &&
                        tokens.types[current + 1] == lang::token_i::DOT &&
                        tokens.types[current + 2] == lang::token_i::DOT)
                    {
                        advance(); // first dot
                        advance(); // second dot
                        advance(); // third dot
                    }
                    else
                    {
                        report_error(create_parse_error(
                            ParseErrorFlags::INVALID_SYNTAX,
                            ErrorSeverity::ERROR,
                            "Variadic parameter must have '...' after type",
                            "Add '...' after the parameter type for variadic parameters",
                            current
                        ));
                        return ParseResult<uint32_t>::failure();
                    }
                }

                if (current_token.type == lang::token_i::COMMA)
                    advance();
                else if (current_token.type != lang::token_i::RIGHT_PAREN)
                    break;
            }

            if (current_token.type != lang::token_i::RIGHT_PAREN)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected ')' to close parameter list",
                    "Close parameter list with ')'",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();

            if (current_token.type != lang::token_i::MINUS)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected '-' before return type",
                    "Specify return type with '->'",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();

            if (current_token.type != lang::token_i::GREATER)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected '>' to complete return type arrow",
                    "Complete return type specification with '->'",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();

            auto return_type_result = parse_type();
            if (!return_type_result)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid return type",
                    "Provide a valid return type",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }

            const uint32_t function_type_index = types.names.size();
            types.names.push_back("function");
            types.function_param_starts.push_back(param_start);
            types.function_param_counts.push_back(param_count);
            types.function_return_types.push_back(return_type_result.value);

            if (generic_start != std::numeric_limits<uint32_t>::max())
            {
                types.generic_starts.push_back(generic_start);
                types.generic_counts.push_back(generic_count);
            }
            else
            {
                types.generic_starts.push_back(0);
                types.generic_counts.push_back(0);
            }

            if (current_token.type != lang::token_i::LEFT_BRACE)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected '{' to start function body",
                    "Open function body with '{'",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();

            if (const auto function_body = parse_statement();
                !function_body)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid function body",
                    "Provide a valid function body",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();

            expressions.expr_types.emplace_back(static_cast<uint8_t>(function_type_index));
            expressions.values.emplace_back(std::string_view {});
            return ParseResult(expr_index);
        }
        if (current_token.type == lang::token_i::LEFT_PAREN)
        {
            advance();
            auto inner_expr = parse_expression();
            if (!inner_expr)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid expression inside parentheses",
                    "Provide a valid expression inside ()",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }

            if (current_token.type != lang::token_i::RIGHT_PAREN)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::UNEXPECTED_TOKEN,
                    ErrorSeverity::ERROR,
                    "Expected closing parenthesis ')'",
                    "Close the parenthesized expression with ')'",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
            advance();
        }
        // primary expr
        else
        {
            switch (current_token.type)
            {
                case lang::token_i::NUM_LITERAL:
                case lang::token_i::TRUE:
                case lang::token_i::FALSE:
                case lang::token_i::NIL:
                case lang::token_i::STR_LITERAL:
                {
                    expressions.expr_types.emplace_back(static_cast<uint8_t>(current_token.type));
                    expressions.values.emplace_back(std::string_view {
                        source + tokens.starts[current],
                        tokens.lengths[current]
                    });
                    advance();
                    break;
                }
                case lang::token_i::IDENTIFIER:
                {
                    expressions.expr_types.emplace_back(static_cast<uint8_t>(current_token.type));
                    expressions.values.emplace_back(std::string_view {
                        source + tokens.starts[current],
                        tokens.lengths[current]
                    });
                    advance();
                    break;
                }
                default:
                {
                    report_error(create_parse_error(
                        ParseErrorFlags::UNEXPECTED_TOKEN,
                        ErrorSeverity::ERROR,
                        "Invalid expression",
                        "Provide a valid literal or expression",
                        current
                    ));
                    return ParseResult<uint32_t>::failure();
                }
            }
        }

        // check by precedence order from high to low
        while (current_token.type == lang::token_i::STAR || // mult
               current_token.type == lang::token_i::SLASH ||
               current_token.type == lang::token_i::PERCENT ||
               current_token.type == lang::token_i::PLUS || // add
               current_token.type == lang::token_i::MINUS ||
               current_token.type == lang::token_i::AND || // bitwise
               current_token.type == lang::token_i::OR ||
               current_token.type == lang::token_i::XOR)
        {
            expressions.expr_types.emplace_back(static_cast<uint8_t>(current_token.type));
            expressions.values.emplace_back(std::string_view {
                source + tokens.starts[current],
                tokens.lengths[current]
            });
            advance();

            if (const auto right_operand_result = parse_expression();
                !right_operand_result)
            {
                report_error(create_parse_error(
                    ParseErrorFlags::INVALID_SYNTAX,
                    ErrorSeverity::ERROR,
                    "Invalid expression after binary operator",
                    "Provide a valid expression after the operator",
                    current
                ));
                return ParseResult<uint32_t>::failure();
            }
        }

        return ParseResult(expr_index);
    }

    /**
     * @brief Retrieves the source code line corresponding to a given line number.
     *
     * This method extracts the full text of a specific line from the source code by navigating
     * through the source character array. It handles finding the start and end of the requested line.
     *
     * @param line_number The line number to retrieve (1-based indexing)
     * @return std::string The text of the specified source code line
     * @note If the line number is beyond the source code length, returns an empty string
     * @note Handles both Unix-style (\n) and potentially Windows-style (\r\n) line endings
     */
    std::string Parser::get_source_line(const uint32_t line_number) const
    {
        uint32_t current_line = 1;
        uint32_t pos = 0;
        while (current_line < line_number && source[pos] != '\0')
        {
            if (source[pos] == '\n')
                current_line++;
            pos++;
        }

        while (pos > 0 && source[pos - 1] != '\n')
        {
            pos--;
        }

        uint32_t line_end = pos;
        while (source[line_end] != '\n' && source[line_end] != '\0')
        {
            line_end++;
        }

        return std::string(source + pos, line_end - pos);
    }

    /**
     * @brief Creates a visual pointer to highlight the location of an error in the source code.
     *
     * Generates a string that visually indicates the exact column and span of a token
     * where an error occurred. The pointer consists of spaces leading up to the error
     * column, followed by a caret (^) and tildes (~) to show the token's length.
     *
     * @param column The index of the token in the token list where the error occurred.
     * @return std::string A formatted string representing a visual error pointer.
     *
     * @example
     * If the error is at column 5 with a token length of 3, the output might look like:
     *     "     ^~~~"
     *
     * @note This method is used for generating detailed error messages in source code parsing.
     */
    std::string Parser::create_error_pointer(const uint32_t column) const
    {
        const uint32_t start = tokens.starts[column];
        const uint16_t length = tokens.lengths[column];

        uint32_t line_start = start;
        while (line_start > 0 && source[line_start - 1] != '\n')
            line_start--;

        const uint32_t col = start - line_start;

        std::string pointer(col, ' ');
        pointer += "^" + std::string(length, '~');
        return pointer;
    }

    /**
     * @brief Synchronizes the parser after encountering an error by skipping tokens.
     *
     * This method helps recover from parsing errors by advancing through tokens until
     * a semicolon is found or the end of the token stream is reached. It allows the
     * parser to continue processing subsequent tokens after encountering a syntax error.
     *
     * @details The synchronization process works as follows:
     * - Continues advancing through tokens while not at the end of the token stream
     * - If a semicolon is encountered, advances past it and returns, effectively
     *   resetting the parsing state to a known good point
     * - If no semicolon is found, continues until the end of the token stream
     *
     * @note This method is typically used in error recovery to prevent cascading
     * parsing errors and allow the parser to continue processing the source code.
     */
    void Parser::synchronize()
    {
        while (!is_at_end())
        {
            if (current_token.type == lang::token_i::SEMICOLON)
            {
                advance();
                return;
            }
            advance();
        }
    }

    /**
     * @brief Reports parsing errors with detailed diagnostic information.
     *
     * Handles error reporting for different severity levels (warning, error, fatal),
     * providing comprehensive error details including source location, context,
     * and optional suggestions for resolution.
     *
     * @param error A ParseError object containing error details
     *
     * @details
     * - For warnings and errors, prints colored diagnostic output to stderr
     * - Displays error message, source file, line, and column information
     * - Shows the problematic source line with an error pointer
     * - Provides optional help/suggestion text
     * - Includes an error code for tracking
     *
     * Error handling behavior:
     * - Warnings are logged and stored
     * - Errors trigger parser synchronization
     * - Fatal errors throw a runtime exception
     *
     * @note Uses terminal color styling for improved readability
     * @note Supports different error severity levels with distinct handling
     */
    void Parser::report_error(const ParseError &error)
    {
        if (error.severity >= ErrorSeverity::WARNING)
        {
            const auto &color = error.severity == ErrorSeverity::WARNING
                                    ? styles::color::YELLOW
                                    : styles::color::RED;

            std::cerr << color
                    << (error.severity == ErrorSeverity::WARNING ? "warning" : "error")
                    << styles::color::RESET << ": "
                    << error.message << std::endl;

            std::cerr << "  " << styles::color::BLUE << "-->" << styles::color::RESET
                    << " " << error.filename << ":"
                    << error.line << ":" << error.column << std::endl;

            if (!error.source_line.empty())
            {
                std::cerr << styles::color::BLUE << "   |" << styles::color::RESET << std::endl;
                std::cerr << styles::color::BLUE << std::setw(3) << error.line
                        << "|" << styles::color::RESET << " "
                        << error.source_line << std::endl;
                std::cerr << styles::color::BLUE << "   |" << styles::color::RESET << " "
                        << error.error_pointer << std::endl;
            }

            if (!error.suggestion.empty())
            {
                std::cerr << styles::color::BLUE << "   |" << styles::color::RESET << std::endl;
                std::cerr << styles::color::BLUE << "   = " << styles::color::RESET
                        << styles::color::GREEN << "help" << styles::color::RESET
                        << ": " << error.suggestion << std::endl;
            }

            std::cerr << styles::color::BLUE << "   = " << styles::color::RESET
                    << "note: error[" << get_error_code(error.flags) << "]" << "\n";
        }

        switch (error.severity)
        {
            case ErrorSeverity::WARNING:
                warnings.emplace_back(error);
                break;

            case ErrorSeverity::ERROR:
                synchronize();
                break;

            case ErrorSeverity::FATAL:
                throw std::runtime_error(error.message);
        }
    }

    /**
     * @brief Maps parse error flags to unique error codes.
     *
     * Converts different types of parsing errors to standardized error codes
     * for consistent error reporting and tracking.
     *
     * @param flags The specific parse error flag to convert
     * @return std::string A unique error code corresponding to the error flag
     *
     * @note Error codes follow a structured format:
     * - E0001: Unexpected token encountered
     * - E0002: Invalid syntax detected
     * - E0308: Type mismatch error
     * - E0433: Unresolved symbol
     * - E0000: Default/unknown error
     */
    std::string Parser::get_error_code(const ParseErrorFlags flags)
    {
        switch (flags)
        {
            case ParseErrorFlags::UNEXPECTED_TOKEN:
                return "E0001";
            case ParseErrorFlags::TYPE_MISMATCH:
                return "E0308";
            case ParseErrorFlags::INVALID_SYNTAX:
                return "E0002";
            case ParseErrorFlags::UNRESOLVED_SYMBOL:
                return "E0433";
            default:
                return "E0000";
        }
    }
}
